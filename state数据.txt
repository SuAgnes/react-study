*****第一种方案*****
1. state 数据
2. JSX模板
3. 数据 + 模板结合, 生成真实DOM, 来显示
4. state 发生改变
5. 数据 + 模板结合, 生成真实DOM, 替换原始DOM

缺陷: 
第一次生成了一个完整的DOM片段
第二次生成了一个完整的DOM片段
第二次的DOM替换第一次的DOM, 非常耗性能


*****第二种方案*****
1. state 数据
2. JSX模板
3. 数据 + 模板结合, 生成真实DOM, 来显示
4. state 发生改变
5. 数据 + 模板结合, 生成真实DOM, 并不直接替换原始的DOM
6. 新的DOM(DocumentFragment:文档碎片,在内存里) 和原始DOM 作比对, 找差异
7. 找出input框发生了变化
8. 只用新的DOM中的input元素, 替换掉老的DOM中的元素

缺陷:
性能的提升并不明显: 提升了替换元素数量的性能, 但新旧DOM做对比同时也降低了性能


*****第三种: React的虚拟DOM提升方案*****
Vue 用的也是虚拟DOM
1. state 数据
2. JSX模板
3. 生成虚拟DOM(虚拟DOM就是一个真实对象, 用它来描述真实DOM) (损耗了极小性能: 用JS生成一个JS对象, 损耗极小; 但是用JS生成一个DOM元素, 代价极高)
   ['div', {id: 'abc'}, ['span', {}, 'Hi']]
4. 用虚拟DOM的结构, 生成真实DOM, 来显示
   <div id="diva"><span>Hi</span></div>
5. state 发生改变
6. 数据 + 模板 生成新的虚拟DOM (极大的提升了性能)
   ['div', {id: 'abc'}, ['span', {}, 'Bye']]
7. 比较原始虚拟DOM和新的虚拟DOM的区别, 找到区别是span中的内容 (极大的提升了性能)
   diff算法: difference
8. 直接操作DOM, 改变span中的内容

优点: 
1. 性能提升
2. 它使得跨端应用得以实现 - React Native 
   (在移动原生应用里(Android/IOS)根本没有DOM概念, 如果没有虚拟DOM, 生成的DOM在原生应用里根本无法使用, 代码只能运行在浏览器中)
   (但虚拟DOM-js对象在浏览器里可以被识别, 同时在原生应用里也可以被识别, 所以虚拟DOM无论是在原生应用里或者是在网页应用里都可以被正确的识别)
   (在浏览器中, 可以把虚拟DOM转换成真实DOM使用, 在原生应用里, 可以把虚拟DOM转化为原生应用组件, 这样使得react既可以开发网页应用, 也可以开发原生应用)

   setState是异步的, 为了提升react底层的性能: 假如连续三次调用setState, 变更三组数据, 如果这三次setState时间间隔很小, 那么会很浪费性能
   在react上, 如果连续调用三次setState, react就会把三次setState合并成一次setState, 只去做一次虚拟DOM的比对, 然后去更新一次DOM, 这样可以省去额外两次DOM比对带来的性能上的耗费

   比较虚拟DOM的时候, 是同层比对, 如果第一层一致, 再去比较第二层
   假如react比对的时候, 第一层虚拟DOM就不一致, 那么react就不会再去往下比了, react会把原始节点的DOM以及下面所有的DOM全部删除, 重新生成一遍DOM, 再用重新生成的DOM替换原始的DOM
   虽然这种比对有可能造成一些DOM节点的浪费, 但是同层比对的好处是比对的算法非常的简单, 算法简单带来的好处就是比对的速度会非常快, 所以虽然可能造成DOM重新渲染的一些浪费, 但是大大的减少了两个虚拟DOM之间比对的算法的性能消耗
   虚拟DOM的比对, 会根据key值做关联, 比对key值
   所以说不要用index作key值, 因为如果用index做key值, 就没办法保证在原始的虚拟DOM树上的key值和新的虚拟DOM树上的key值一致了, 可以用item做key值(保持key值的稳定性)